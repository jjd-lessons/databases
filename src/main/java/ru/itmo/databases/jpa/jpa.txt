#### Требования к entity-классам:
1. перечисление или интерфейс не могут быть определены как сущность
2. могут быть абстрактными
3. не должны быть final (это необходимо для ленивой загрузки связанных данных)
4. могут расширять обычные Java классы (не entity-классы), а также entity-классы и наоборот
5. должны быть классами верхнего уровня
6. должны быть аннотирован аннотацией javax.persistence.Entity
7. классы должен иметь public или protected конструктор без аргументов,
также могут определять дополнительные конструкторы с аргументами
8. должен иметь уникальный идентификатор, аннотированный аннотацией
 javax.persistence.Id или javax.persistence.EmbeddedId
9. доступ к свойствам должен обеспечиваться через геттеры и сеттеры


#### Допустимые типы атрибутов у entity-классов:
1. примитивные типы и их классы-обертки
2. строки
3. BigDecimal и BigInteger
4. java.util.Date, java.util.Calendar, java.sql.Date,
java.sql.Time, java.sql.Timestamp
5. перечисления
6. любые типы, имплементирующие Serializable
7. entity-типы
8. коллекции
9. с появлением java 8 появилась возможность использовать классы из пакета java.time
10. [в Hibernate есть возможность использовать org.hibernate.type с аннотацией
@Type, а также определять пользовательские типы]

#### Типы связей между Entity:
1. @OneToOne - связь один к одному,
один экземпляр entity-класса может связан с одним объектом другого entity-класса.
Ссылка на связь может быть установлена только с одной стороны

2. @OneToMany - связь один ко многим,
один объект entity-класса может быть связан
с несколькими объектами другого entity-класса

3. @ManyToOne - связь многие к одному, обратная связь для OneToMany

4. @ManyToMany - связь многие ко многим,
несколько объектов entity-класса могут быть связаны
с несколькими объектами другого entity-класса

#### Fetch стратегии для извлечения связанных сущностей:
1. LAZY — данные поля будут загружены только во время первого доступа к этому полю
2. EAGER — данные поля будут загружены немедленно